### 面试题2：实现Singleton模式

#### 题目：
设计一个类，我们只能生成该类的一个实例。

#### 拓展：
在前面的代码中，单例模式的实现我们把类型标志为final，表示它们不能作为其他类型的基类。现在我们要求定义一个表示总统的类型President，可以从该类继承出FrenchPresident和AmericanPresident等类型。这些派生类型都只能产生一个实例。请问该如何设计实现这些类型？

### 解题思路
方法一，只适合单线程环境。 加上final修饰符，防止用户继承该类，使用clone方法创建出该单例实例的另一个实例。<br/><br/>

方法二：虽然在多线程环境中能工作，但工作效率不高（初步饱汉式） 。加上final修饰符，防止用户继承该类，使用clone方法创建出该单例实例的另一个实例。<br/><br/>


方法三：可行的解法，加同步锁前后两次判断实例是否已存在（完整饿汉式），不过较复杂。加上final修饰符，防止用户继承该类，使用clone方法创建出该单例实例的另一个实例。<br/><br/>

方法四（推荐1）：饿汉式，一般开发使用这个。加上final修饰符，防止用户继承该类，使用clone方法创建出该单例实例的另一个实例.<br/><br/>

方法五：使用了内部类创建实例。 加上final修饰符，防止用户继承该类，使用clone方法创建出该单例实例的另一个实例。使用内部类可以避免这个问题，因为在多线程环境下，jvm对一个类的初始化会做限制，同一时间只会允许一个线程去初始化一个类，这样就从虚拟机层面避免了大部分单例实现的问题. 参考链接：
 (https://blog.csdn.net/gavin_dyson/article/details/70145374)[https://blog.csdn.net/gavin_dyson/article/details/70145374]
 <br/><br/>
 
方法六（推荐2）：枚举式单例。这种方法不仅能解决多线程同步问题，而且能防止反序列化重新创建新的对象，不过由于jdk1.5中才加入enum特性，所以不常用。调用方法Singleton6.INSTANCE.getResource();<br/><br/>
 
方法七：登记式，spring IOC 就是使用该方法实现<br/><br/>
<hr/>
